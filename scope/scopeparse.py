"""SCOPe Module

SCOPe fragments location parser

Usage:
	from scope import scopeparser as scope_parser
	
Example :
	

	# scope parser initialization	
	p = Parser('/home/welhefna/scope2.06New/newAnalysis/NewDataSetsFragments/fragments/fragments/40/L7/939/7/0.1/shift/aa/FRAG/d2aama1.LOC')

	print p.fragments
	print p.fragments_frequency		# print fragments and frequencey of each fragment
	print p.fragments_length		# print length of each fragment
	print p.number_of_residues		# print number of residues
	print p.gaps				# print list of gaps 
	print p.range				# print start , end range of residues
	print p.get_all_fragments_information() # print all fragments information

Notes:
	part of research project.

TODO:
	*Extend methods depend on research needs.
"""

import os
import sys
import re
from collections import defaultdict

class SCOPeParser(object):
	"""SCOPe Parser
	
	Parse SCOPe fragments location generated by scope2frag.py on HPC architure.
	
	Attributes:
	
		fragments (list) : list of fragments, each fragment is a dictionary has four keys <start, end, RMSD .
		_fragments_frequency (default_dict) : key is the fragment sequence id, value is frequence of fragment.
	Note:
	
	"""

	__slots__ = ['_fragments', '_fragments_frequency', '_number_of_residues']
	
	def __init__(self, file_path):
		"""Initialize
		
		Initialize SCOPe fragments file.
		
		Args:
			file_path (str) : full ile path in string format.
		
		Kwargs:
			None.
		
		Returns:
			None.
		
		Raises:
			IOError : file not found.
			
		"""
		
		self._fragments = {
					'start_index': None,
					'end_index' : None,
					'fragment_length' : None,
					'fragments' : [],
					'GAP' : [],
				}
				
		self._fragments_frequency = defaultdict(int)
		self._number_of_residues = 0
		
		if os.path.exists(file_path):
			with open(file_path,'r') as scope_file:
				lines = scope_file.readlines()
				if len(lines) > 0 :
					
					
					self._fragments['start_index'] = int((lines[0].split(' '))[0])
					self._fragments['end_index'] = int((lines[-1].split(' '))[1])
					self._fragments['fragment_length'] = abs( int((lines[0].split(' '))[0]) - int((lines[0].split(' '))[1]) ) + 1
					
					t_GAPS = []
					lines = map(str.strip, lines)
					
					for line in lines:
						line = re.sub(' +',' ',line)
						parts = line.split(' ')

						if not(parts[-1] == '-1' or parts[-1] == 'GAP'):
							
							t = {
								'start' : int(parts[0]),
								'end' : int(parts[1]),
								'RMSD' : round(float(parts[2]),4),
								'sequence_id' : int(parts[3]),
							}

							self._fragments['fragments'].append(t)
							self._fragments_frequency[int(parts[3])] += 1
							
							t_GAPS.append('')
							
						elif parts[-1] == 'GAP' :
							
							t_GAPS.extend([int(parts[0]),int(parts[1])])
						else:
							self._number_of_residues += 1
							t_GAPS.append('')
			
			index = 0
			start_flag = 0
			end_flag = 0
			while index < len(t_GAPS):
				if t_GAPS[index] != '' and start_flag == 0:
				
					start = t_GAPS[index]
					start_flag = 1
					
				elif t_GAPS[index] != '' and start_flag == 1 :
				
					end = t_GAPS[index]
					end_flag = 1
					
				else:
					if end_flag == 1:
						self._fragments['GAP'].append((start,end))
						start_flag = 0
						end_flag = 0
				index += 1
				
			self._fragments['GAP'].append((start,end))			
			
		else:
			raise IOError( " File {} not valid path or not available ".format(file_path))
	
	@property	
	def fragments_frequency(self):
		"""Fragments Frequency
		
		Fragments frequencey dictionary 
		
		Args:
			None.
		Kwargs:
			None.
		Returns:
			fragments frequencey dictionary where key is fragment sequence id, and value is oocurance of fragment
		Raises:
			None.
		
		"""
		
		return self._fragments_frequency
		
	@property
	def fragments(self):
		"""Fragments
		
		Fragments informat
		
		Args:
			None.
		Kwargs:
			None.
		Returns:
			fragments list of dictionaries, each dictionary is a fragmnet defined by start_index (int), end_index (int), sequence_id (int), and its RMSD (decimal).
		Raises:
			None.
		
		"""
		
		return self._fragments['fragments']
	
	@property
	def fragments_length(self):
		"""Fragment Length
		
		Common fragment length.
		
		Args:
			None.
		Kwargs:
			None.
		Returns:
			fragments length as integer.
		Raises:
			None.
		
		"""
		
		return self._fragments['fragment_length']
		
	@property
	def number_of_residues(self):
		"""Number of Residues
		
		Fragments length
		
		Args:
			None.
		Kwargs:
			None.
		Returns:
			actual number of residues as integer.
		Raises:
			None.
		
		"""
		
		return self._number_of_residues
		
	@property
	def gaps(self):
		"""GAPS
		
		Fragments length
		
		Args:
			None.
		Kwargs:
			None.
		Returns:
			list of gaps in the protein sequence each has start and end as tuple.
		Raises:
			None.
		
		"""
		
		return self._fragments['GAP']
		
	@property
	def range(self):
		"""Rang
		
		Fragments start and end indecies.
		
		Args:
			None.
		Kwargs:
			None.
		Returns:
			 start index, end index as tuple.
		Raises:
			None.
		
		"""
		
		return self._fragments['start_index'], self._fragments['end_index']
		
	def get_all_fragments_information(self):
		"""Get All Fragments
		
		get all fragments information from the scope loc file.
		
		Args:
			None.
		Kwargs:
			None.
		Returns:
			dictionary contains all fragments information start (int), end(int), fragments (list), fragment_length (int), and gaps (list).
		Raises:
			None.
		
		"""
		
		return self._fragments
		
		
		
		
if __name__ == "__main__" :
	pass

